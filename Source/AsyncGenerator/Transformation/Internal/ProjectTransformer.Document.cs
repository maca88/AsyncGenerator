using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AsyncGenerator.Analyzation;
using AsyncGenerator.Core;
using AsyncGenerator.Core.Analyzation;
using AsyncGenerator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SyntaxNodeExtensions = AsyncGenerator.Extensions.Internal.SyntaxNodeExtensions;

namespace AsyncGenerator.Transformation.Internal
{
	partial class ProjectTransformer
	{
		private DocumentTransformationResult TransformDocument(IDocumentAnalyzationResult documentResult)
		{
			var rootNode = documentResult.Node;
			var endOfLineTrivia = rootNode.DescendantTrivia().First(o => o.IsKind(SyntaxKind.EndOfLineTrivia));
			var result = new DocumentTransformationResult(documentResult)
			{
				EndOfLineTrivia = endOfLineTrivia
			};
			// Annotate so that the annotation exposed is valid
			rootNode = rootNode.WithAdditionalAnnotations(new SyntaxAnnotation(result.Annotation));

			var globalNsTransformResult = new RootNamespaceTransformationResult(documentResult.GlobalNamespace);
			foreach (var typeResult in documentResult.GlobalNamespace.Types.Where(o => o.Conversion != TypeConversion.Ignore))
			{
				var typeSpanStart = typeResult.Node.SpanStart;
				var typeSpanLength = typeResult.Node.Span.Length;
				var typeNode = rootNode.DescendantNodesAndSelf()
					.OfType<TypeDeclarationSyntax>()
					.First(o => o.SpanStart == typeSpanStart && o.Span.Length == typeSpanLength);
				var transformResult = TransformType(typeResult, globalNsTransformResult);
				result.TransformedTypes.Add(transformResult);
				rootNode = rootNode.ReplaceNode(typeNode, typeNode.WithAdditionalAnnotations(new SyntaxAnnotation(transformResult.Annotation)));
			}

			foreach (var namespaceResult in documentResult.GlobalNamespace.NestedNamespaces.OrderBy(o => o.Node.SpanStart))
			{
				var namespaceSpanStart = namespaceResult.Node.SpanStart;
				var namespaceSpanLength = namespaceResult.Node.Span.Length;
				var namespaceNode = rootNode.DescendantNodesAndSelf()
					.OfType<NamespaceDeclarationSyntax>()
					.First(o => o.SpanStart == namespaceSpanStart && o.Span.Length == namespaceSpanLength);
				var transformResult = TransformNamespace(namespaceResult);
				result.TransformedNamespaces.Add(transformResult);
				rootNode = rootNode.ReplaceNode(namespaceNode, namespaceNode.WithAdditionalAnnotations(new SyntaxAnnotation(transformResult.Annotation)));
			}

			// Save the orignal node that was only annotated
			var originalAnnotatedNode = rootNode;

			// TODO: use the same pattern as in namespace and type transformation
			var transformResults = result.TransformedNamespaces
				.Cast<ITransformationResult>()
				.Concat(result.TransformedTypes)
				.ToList();

			var newMembers = transformResults
				.OrderBy(o => o.OriginalStartSpan)
				.SelectMany(o => o.GetTransformedNodes())
				.OfType<MemberDeclarationSyntax>()
				.ToList();

			if (!newMembers.Any())
			{
				return result; // the document will not be created
			}
			rootNode = rootNode
				.WithMembers(List(newMembers));

			// Update the original document if required
			foreach (var rewrittenNode in transformResults.Where(o => o.OriginalModified != null).OrderByDescending(o => o.OriginalStartSpan))
			{
				if (result.OriginalModified == null)
				{
					result.OriginalModified = originalAnnotatedNode;
				}
				result.OriginalModified = result.OriginalModified
					.ReplaceNode(result.OriginalModified
						.GetAnnotatedNodes(rewrittenNode.Annotation).First(), rewrittenNode.OriginalModified);
			}

			// Add auto-generated comment
			rootNode = rootNode.WithLeadingTrivia(
				SyntaxNodeExtensions.AddAutoGeneratedTrivia(endOfLineTrivia).AddRange(rootNode.GetLeadingTrivia()));

			result.Transformed = rootNode;
			return result;
		}
	}
}
